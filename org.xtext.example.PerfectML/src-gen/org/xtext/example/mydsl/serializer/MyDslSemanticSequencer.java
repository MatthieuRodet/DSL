/*
 * generated by Xtext 2.25.0
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.myDsl.AlgoDeclaration;
import org.xtext.example.mydsl.myDsl.Algorithm;
import org.xtext.example.mydsl.myDsl.BOOL;
import org.xtext.example.mydsl.myDsl.Binop;
import org.xtext.example.mydsl.myDsl.ColumnDeclaration;
import org.xtext.example.mydsl.myDsl.ColumnDeclarations;
import org.xtext.example.mydsl.myDsl.ColumnSet;
import org.xtext.example.mydsl.myDsl.FLOAT;
import org.xtext.example.mydsl.myDsl.File;
import org.xtext.example.mydsl.myDsl.MyDslPackage;
import org.xtext.example.mydsl.myDsl.ParaDeclaration;
import org.xtext.example.mydsl.myDsl.ParameterDeclaration;
import org.xtext.example.mydsl.myDsl.Program;
import org.xtext.example.mydsl.myDsl.TargetPredictive;
import org.xtext.example.mydsl.myDsl.Value;
import org.xtext.example.mydsl.services.MyDslGrammarAccess;

@SuppressWarnings("all")
public class MyDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MyDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MyDslPackage.ALGO_DECLARATION:
				sequence_AlgoDeclaration(context, (AlgoDeclaration) semanticObject); 
				return; 
			case MyDslPackage.ALGORITHM:
				sequence_Algorithm(context, (Algorithm) semanticObject); 
				return; 
			case MyDslPackage.BOOL:
				sequence_BOOL(context, (BOOL) semanticObject); 
				return; 
			case MyDslPackage.BINOP:
				sequence_Binop(context, (Binop) semanticObject); 
				return; 
			case MyDslPackage.COLUMN_DECLARATION:
				sequence_ColumnDeclaration(context, (ColumnDeclaration) semanticObject); 
				return; 
			case MyDslPackage.COLUMN_DECLARATIONS:
				sequence_ColumnDeclarations(context, (ColumnDeclarations) semanticObject); 
				return; 
			case MyDslPackage.COLUMN_SET:
				sequence_ColumnSet(context, (ColumnSet) semanticObject); 
				return; 
			case MyDslPackage.FLOAT:
				sequence_FLOAT(context, (FLOAT) semanticObject); 
				return; 
			case MyDslPackage.FILE:
				sequence_File(context, (File) semanticObject); 
				return; 
			case MyDslPackage.PARA_DECLARATION:
				sequence_ParaDeclaration(context, (ParaDeclaration) semanticObject); 
				return; 
			case MyDslPackage.PARAMETER_DECLARATION:
				sequence_ParameterDeclaration(context, (ParameterDeclaration) semanticObject); 
				return; 
			case MyDslPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case MyDslPackage.TARGET_PREDICTIVE:
				sequence_TargetPredictive(context, (TargetPredictive) semanticObject); 
				return; 
			case MyDslPackage.VALUE:
				sequence_Value(context, (Value) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AlgoDeclaration returns AlgoDeclaration
	 *
	 * Constraint:
	 *     (Name=ID Value=Value)
	 */
	protected void sequence_AlgoDeclaration(ISerializationContext context, AlgoDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ALGO_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ALGO_DECLARATION__NAME));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ALGO_DECLARATION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ALGO_DECLARATION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAlgoDeclarationAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getAlgoDeclarationAccess().getValueValueParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Algorithm returns Algorithm
	 *
	 * Constraint:
	 *     (Name=ID Bloc+=AlgoDeclaration*)
	 */
	protected void sequence_Algorithm(ISerializationContext context, Algorithm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BOOL returns BOOL
	 *
	 * Constraint:
	 *     (value='true' | value='false')
	 */
	protected void sequence_BOOL(ISerializationContext context, BOOL semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Binop returns Binop
	 *
	 * Constraint:
	 *     (type='and' | type='except')
	 */
	protected void sequence_Binop(ISerializationContext context, Binop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ColumnDeclaration returns ColumnDeclaration
	 *
	 * Constraint:
	 *     (Columns=ColumnSet Type=TargetPredictive)
	 */
	protected void sequence_ColumnDeclaration(ISerializationContext context, ColumnDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.COLUMN_DECLARATION__COLUMNS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.COLUMN_DECLARATION__COLUMNS));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.COLUMN_DECLARATION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.COLUMN_DECLARATION__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getColumnDeclarationAccess().getColumnsColumnSetParserRuleCall_0_0(), semanticObject.getColumns());
		feeder.accept(grammarAccess.getColumnDeclarationAccess().getTypeTargetPredictiveParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ColumnDeclarations returns ColumnDeclarations
	 *
	 * Constraint:
	 *     Bloc+=ColumnDeclaration*
	 */
	protected void sequence_ColumnDeclarations(ISerializationContext context, ColumnDeclarations semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ColumnSet returns ColumnSet
	 *
	 * Constraint:
	 *     ((ArgBin1=ColumnSet opType=Binop ArgBin2=ColumnSet) | (ArgR1=INT ArgR2=INT) | (ArgList+=INT* ArgList+=INT))
	 */
	protected void sequence_ColumnSet(ISerializationContext context, ColumnSet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FLOAT returns FLOAT
	 *
	 * Constraint:
	 *     (IntPart=INT DecPart=INT)
	 */
	protected void sequence_FLOAT(ISerializationContext context, FLOAT semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.FLOAT__INT_PART) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.FLOAT__INT_PART));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.FLOAT__DEC_PART) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.FLOAT__DEC_PART));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFLOATAccess().getIntPartINTTerminalRuleCall_0_0(), semanticObject.getIntPart());
		feeder.accept(grammarAccess.getFLOATAccess().getDecPartINTTerminalRuleCall_2_0(), semanticObject.getDecPart());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     File returns File
	 *
	 * Constraint:
	 *     PATH=STRING
	 */
	protected void sequence_File(ISerializationContext context, File semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.FILE__PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.FILE__PATH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFileAccess().getPATHSTRINGTerminalRuleCall_1_0(), semanticObject.getPATH());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ParaDeclaration returns ParaDeclaration
	 *
	 * Constraint:
	 *     (Name=ID Value=Value)
	 */
	protected void sequence_ParaDeclaration(ISerializationContext context, ParaDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PARA_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PARA_DECLARATION__NAME));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PARA_DECLARATION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PARA_DECLARATION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParaDeclarationAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getParaDeclarationAccess().getValueValueParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ParameterDeclaration returns ParameterDeclaration
	 *
	 * Constraint:
	 *     Bloc+=ParaDeclaration*
	 */
	protected void sequence_ParameterDeclaration(ISerializationContext context, ParameterDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Program returns Program
	 *
	 * Constraint:
	 *     (blocsFile=File blocsAlgo=Algorithm blocsPara=ParameterDeclaration blocsColu=ColumnDeclarations)
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PROGRAM__BLOCS_FILE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PROGRAM__BLOCS_FILE));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PROGRAM__BLOCS_ALGO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PROGRAM__BLOCS_ALGO));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PROGRAM__BLOCS_PARA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PROGRAM__BLOCS_PARA));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PROGRAM__BLOCS_COLU) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PROGRAM__BLOCS_COLU));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProgramAccess().getBlocsFileFileParserRuleCall_0_0(), semanticObject.getBlocsFile());
		feeder.accept(grammarAccess.getProgramAccess().getBlocsAlgoAlgorithmParserRuleCall_1_0(), semanticObject.getBlocsAlgo());
		feeder.accept(grammarAccess.getProgramAccess().getBlocsParaParameterDeclarationParserRuleCall_2_0(), semanticObject.getBlocsPara());
		feeder.accept(grammarAccess.getProgramAccess().getBlocsColuColumnDeclarationsParserRuleCall_3_0(), semanticObject.getBlocsColu());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TargetPredictive returns TargetPredictive
	 *
	 * Constraint:
	 *     (type='target' | type='predictive')
	 */
	protected void sequence_TargetPredictive(ISerializationContext context, TargetPredictive semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Value returns Value
	 *
	 * Constraint:
	 *     (int=INT | str=STRING | float=FLOAT | bool=BOOL)
	 */
	protected void sequence_Value(ISerializationContext context, Value semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
