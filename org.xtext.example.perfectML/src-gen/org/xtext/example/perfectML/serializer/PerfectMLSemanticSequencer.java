/*
 * generated by Xtext 2.25.0
 */
package org.xtext.example.perfectML.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.perfectML.perfectML.BOOL;
import org.xtext.example.perfectML.perfectML.Binop;
import org.xtext.example.perfectML.perfectML.ColumnDeclarations;
import org.xtext.example.perfectML.perfectML.ColumnSet;
import org.xtext.example.perfectML.perfectML.FLOAT;
import org.xtext.example.perfectML.perfectML.Input;
import org.xtext.example.perfectML.perfectML.KNeighborsClassifier;
import org.xtext.example.perfectML.perfectML.MLPClassifier;
import org.xtext.example.perfectML.perfectML.Output;
import org.xtext.example.perfectML.perfectML.PerfectMLFile;
import org.xtext.example.perfectML.perfectML.PerfectMLPackage;
import org.xtext.example.perfectML.perfectML.Program;
import org.xtext.example.perfectML.perfectML.SVC;
import org.xtext.example.perfectML.perfectML.TrainingAmount;
import org.xtext.example.perfectML.services.PerfectMLGrammarAccess;

@SuppressWarnings("all")
public class PerfectMLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private PerfectMLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == PerfectMLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case PerfectMLPackage.BOOL:
				sequence_BOOL(context, (BOOL) semanticObject); 
				return; 
			case PerfectMLPackage.BINOP:
				sequence_Binop(context, (Binop) semanticObject); 
				return; 
			case PerfectMLPackage.COLUMN_DECLARATIONS:
				sequence_ColumnDeclarations(context, (ColumnDeclarations) semanticObject); 
				return; 
			case PerfectMLPackage.COLUMN_SET:
				sequence_ColumnSet(context, (ColumnSet) semanticObject); 
				return; 
			case PerfectMLPackage.FLOAT:
				sequence_FLOAT(context, (FLOAT) semanticObject); 
				return; 
			case PerfectMLPackage.INPUT:
				sequence_Input(context, (Input) semanticObject); 
				return; 
			case PerfectMLPackage.KNEIGHBORS_CLASSIFIER:
				sequence_KNeighborsClassifier(context, (KNeighborsClassifier) semanticObject); 
				return; 
			case PerfectMLPackage.MLP_CLASSIFIER:
				sequence_MLPClassifier(context, (MLPClassifier) semanticObject); 
				return; 
			case PerfectMLPackage.OUTPUT:
				sequence_Output(context, (Output) semanticObject); 
				return; 
			case PerfectMLPackage.PERFECT_ML_FILE:
				sequence_PerfectMLFile(context, (PerfectMLFile) semanticObject); 
				return; 
			case PerfectMLPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case PerfectMLPackage.SVC:
				sequence_SVC(context, (SVC) semanticObject); 
				return; 
			case PerfectMLPackage.TRAINING_AMOUNT:
				sequence_TrainingAmount(context, (TrainingAmount) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     BOOL returns BOOL
	 *
	 * Constraint:
	 *     (value='True' | value='False')
	 */
	protected void sequence_BOOL(ISerializationContext context, BOOL semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Binop returns Binop
	 *
	 * Constraint:
	 *     (type='and' | type='except')
	 */
	protected void sequence_Binop(ISerializationContext context, Binop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ColumnDeclarations returns ColumnDeclarations
	 *
	 * Constraint:
	 *     (target=ColumnSet target_def?='target' (predictive=ColumnSet pred_def?='predictive')?)
	 */
	protected void sequence_ColumnDeclarations(ISerializationContext context, ColumnDeclarations semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ColumnSet returns ColumnSet
	 *
	 * Constraint:
	 *     ((op?='(' ArgBin1=ColumnSet opType=Binop ArgBin2=ColumnSet) | (range?='From' ArgR1=INT ArgR2=INT) | (list?='[' ArgList+=INT* ArgList+=INT))
	 */
	protected void sequence_ColumnSet(ISerializationContext context, ColumnSet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FLOAT returns FLOAT
	 *
	 * Constraint:
	 *     (IntPart=INT DecPart=INT)
	 */
	protected void sequence_FLOAT(ISerializationContext context, FLOAT semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PerfectMLPackage.Literals.FLOAT__INT_PART) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PerfectMLPackage.Literals.FLOAT__INT_PART));
			if (transientValues.isValueTransient(semanticObject, PerfectMLPackage.Literals.FLOAT__DEC_PART) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PerfectMLPackage.Literals.FLOAT__DEC_PART));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFLOATAccess().getIntPartINTTerminalRuleCall_0_0(), semanticObject.getIntPart());
		feeder.accept(grammarAccess.getFLOATAccess().getDecPartINTTerminalRuleCall_2_0(), semanticObject.getDecPart());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Input returns Input
	 *
	 * Constraint:
	 *     PATH=STRING
	 */
	protected void sequence_Input(ISerializationContext context, Input semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PerfectMLPackage.Literals.INPUT__PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PerfectMLPackage.Literals.INPUT__PATH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInputAccess().getPATHSTRINGTerminalRuleCall_4_0(), semanticObject.getPATH());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Algorithm returns KNeighborsClassifier
	 *     KNeighborsClassifier returns KNeighborsClassifier
	 *
	 * Constraint:
	 *     (
	 *         (n_neighbors_def?='n_neighbors' n_neighbors=INT)? 
	 *         (weights_def?='weights' (weights='uniform' | weights='distance'))? 
	 *         (algorithm_def?='algorithm' (algorithm='auto' | algorithm='ball_tree' | algorithm='kd_tree' | algorithm='brute'))? 
	 *         (leaf_size_def?='leaf_size' leaf_size=INT)? 
	 *         (p_def?='p' p=INT)? 
	 *         (
	 *             metric_def?='metric' 
	 *             (
	 *                 metric='mahalanobis' | 
	 *                 metric='seuclidean' | 
	 *                 metric='wminkowski' | 
	 *                 metric='minkowski' | 
	 *                 metric='chebyshev' | 
	 *                 metric='manhattan' | 
	 *                 metric='euclidean'
	 *             )
	 *         )? 
	 *         (n_jobs_def?='n_jobs' n_jobs=INT)?
	 *     )
	 */
	protected void sequence_KNeighborsClassifier(ISerializationContext context, KNeighborsClassifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Algorithm returns MLPClassifier
	 *     MLPClassifier returns MLPClassifier
	 *
	 * Constraint:
	 *     (
	 *         (hidden_layer_sizes_def?='hidden_layer_sizes' hidden_layer_sizes+=INT hidden_layer_sizes+=INT*)? 
	 *         (activation_def?='activation' (activation='identity' | activation='logistic' | activation='tanh' | activation='relu'))? 
	 *         (solver_def?='solver' (solver='lbfgs' | solver='sgd' | solver='adam'))? 
	 *         (alpha_def?='alpha' alpha=FLOAT)? 
	 *         (batch_size_def?='batch_size' batch_size=INT)? 
	 *         (learning_rate_def?='learning_rate' (learning_rate='constant' | learning_rate='invscaling' | learning_rate='adaptive'))? 
	 *         (learning_rate_init_def?='learning_rate_init' learning_rate_init=FLOAT)? 
	 *         (power_t_def?='power_t' power_t=FLOAT)? 
	 *         (max_iteer_def?='max_iter' max_iter=FLOAT)? 
	 *         (shuffle_def?='shuffle' shuffle=BOOL)? 
	 *         (random_state_def?='random_state' random_state=INT)? 
	 *         (tolerance_def?='tolerance' tolerance=FLOAT)? 
	 *         (verbose_def?='verbose' verbose=BOOL)? 
	 *         (warm_start_def?='warm_start' warm_start=BOOL)? 
	 *         (momentum_def?='momentum' momentum=FLOAT)? 
	 *         (nesterovs_momentum_def?='nesterovs_momentum' nesterovs_momentum=BOOL)? 
	 *         (early_stopping_def?='early_stopping' early_stopping=BOOL)? 
	 *         (validation_fraction_def?='validation_fraction' validation_fraction=FLOAT)? 
	 *         (beta_1_def?='beta_1' beta_1=FLOAT)? 
	 *         (beta_2_def?='beta_2' beta_2=FLOAT)? 
	 *         (epsilon_def?='epsilon' epsilon=FLOAT)? 
	 *         (n_iter_no_change_def?='n_iter_no_change' n_iter_no_change=INT)? 
	 *         (max_fun_def?='max_fun' max_fun=INT)?
	 *     )
	 */
	protected void sequence_MLPClassifier(ISerializationContext context, MLPClassifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Output returns Output
	 *
	 * Constraint:
	 *     PATH=STRING
	 */
	protected void sequence_Output(ISerializationContext context, Output semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PerfectMLPackage.Literals.OUTPUT__PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PerfectMLPackage.Literals.OUTPUT__PATH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOutputAccess().getPATHSTRINGTerminalRuleCall_4_0(), semanticObject.getPATH());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PerfectMLFile returns PerfectMLFile
	 *
	 * Constraint:
	 *     programs+=Program+
	 */
	protected void sequence_PerfectMLFile(ISerializationContext context, PerfectMLFile semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Program returns Program
	 *
	 * Constraint:
	 *     (input=Input output=Output algo=Algorithm nbtraining=TrainingAmount column=ColumnDeclarations?)
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Algorithm returns SVC
	 *     SVC returns SVC
	 *
	 * Constraint:
	 *     (
	 *         (C_def?='C' C=FLOAT)? 
	 *         (kernel_def?='kernel' (kernel='rbf' | kernel='poly' | kernel='linear' | kernel='sigmoid' | kernel='precomputed'))? 
	 *         (degree_def?='degree' degree=INT)? 
	 *         (gamma_def?='gamma' (gamma='scale' | gamma='auto'))? 
	 *         (coef0_def?='coef0' coef0=FLOAT)? 
	 *         (shrinking_def?='shrinking' shrinking=BOOL)? 
	 *         (probability_def?='probability' probability=BOOL)? 
	 *         (tol_def?='tolerance' tol=FLOAT)? 
	 *         (cache_size_def?='cache_size' cache_size=FLOAT)? 
	 *         (verbose_def?='verbose' verbose=BOOL)? 
	 *         (max_iter_def?='max_iter' max_iter=INT)? 
	 *         (decision_function_shape_def?='decision_function_shape' (decision_function_shape='ovo' | decision_function_shape='ovr'))? 
	 *         (break_ties_def?='break_ties' break_ties=BOOL)? 
	 *         (random_state_def?='random_state' random_state=INT)?
	 *     )
	 */
	protected void sequence_SVC(ISerializationContext context, SVC semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TrainingAmount returns TrainingAmount
	 *
	 * Constraint:
	 *     (value=INT percent?='%'?)
	 */
	protected void sequence_TrainingAmount(ISerializationContext context, TrainingAmount semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
